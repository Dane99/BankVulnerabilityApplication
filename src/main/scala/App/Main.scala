package App

import slick.jdbc.SQLiteProfile.api._
import scala.concurrent.{Future, Await}
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.Duration
import scala.util.{Failure, Success}
import io.StdIn._


import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.io.IOException
import java.security.InvalidKeyException
import java.security.Key
import java.security.NoSuchAlgorithmException
import javax.crypto.BadPaddingException
import javax.crypto.Cipher
import javax.crypto.IllegalBlockSizeException
import javax.crypto.NoSuchPaddingException
import javax.crypto.spec.SecretKeySpec


class Accounts(tag: Tag) extends Table[(Int, String, String, String, String, Boolean, Int)](tag, "accounts"){
  def id = column[Int]("id", O.PrimaryKey, O.AutoInc)
  def first = column[String]("first")
  def last = column[String]("last")
  def username = column[String]("username", O.Unique)
  def password = column[String]("password")
  def administrator = column[Boolean]("administrator")
  def balance = column[Int]("balance")
  def * = (id, first, last, username, password, administrator, balance)
}

class Transactions(tag: Tag) extends Table[(Int, Int, Int, Int)](tag, "transactions"){
  def id = column[Int]("id", O.PrimaryKey, O.AutoInc)
  def fromUserID = column[Int]("fromUserID")
  def toUserID = column[Int]("toUserID")
  def transferAmount = column[Int]("transferAmount")
  def * = (id, fromUserID, toUserID, transferAmount)
}


//
//class Suppliers(tag: Tag) extends Table[(Int, String, String, String, String, String)](tag, "suppliers") {
//  def id = column[Int]("sup_id", O.PrimaryKey) // This is the primary key column
//  def name = column[String]("sup_name")
//  def street = column[String]("street")
//  def city = column[String]("city")
//  def state = column[String]("state")
//  def zip = column[String]("zip")
//  // Every table needs a * projection with the same type as the table's type parameter
//  def * = (id, name, street, city, state, zip)
//}

object Main extends App {
  case class User(id: Int, first: String, last: String, username: String, password: String, admin: Boolean, balance: Int)
  case class Transaction(id: Int, fromUserID: Int, toUserID: Int, transferAmt: Int)

  import javax.crypto.BadPaddingException
  import javax.crypto.Cipher
  import javax.crypto.IllegalBlockSizeException
  import javax.crypto.NoSuchPaddingException
  import javax.crypto.spec.SecretKeySpec
  import java.io.FileInputStream
  import java.io.FileOutputStream
  import java.io.IOException
  import java.security.Key
  import java.security.NoSuchAlgorithmException

  import javax.crypto.Cipher

  def deleteFile(filename: String) = { new File(filename).delete() }
  @throws[Exception]
  def encrypt(key: String, inputFile: File, outputFile: File): Unit = {
    performEncryption(Cipher.ENCRYPT_MODE, key, inputFile, outputFile)
  }

  @throws[Exception]
  def decrypt(key: String, inputFile: File, outputFile: File): Unit = {
    performEncryption(Cipher.DECRYPT_MODE, key, inputFile, outputFile)
  }
  @throws[Exception]
  private def performEncryption(cipherMode: Int, key: String, inputFile: File, outputFile: File): Unit = {
    try {
      val secretKey = new SecretKeySpec(key.getBytes, "AES")
      val cipher = Cipher.getInstance("AES")
      cipher.init(cipherMode, secretKey)
      val inputStream = new FileInputStream(inputFile)
      val inputBytes = new Array[Byte](inputFile.length.asInstanceOf[Int])
      inputStream.read(inputBytes)
      val outputBytes = cipher.doFinal(inputBytes)
      val outputStream = new FileOutputStream(outputFile)
      outputStream.write(outputBytes)
      inputStream.close()
      outputStream.close()
    } catch {
      case e =>
        println("Error performing encryption/decryption on file")
    }
  }

  def refresh(db: Database): User = {
    transactionsLog = Await.result(db.run(sql"""select * from transactions""".as[(Int, Int, Int, Int)]), Duration.Inf).toList.map(Transaction tupled _)
    //println(transactionsLog)
    approvedUsers = Await.result(db.run(sql"""select * from accounts""".as[(Int, String, String, String, String, Boolean, Int)]), Duration.Inf).toList.map(User tupled _)
    approvedUsers.filter(_.username == user)(0)
  }

  def dropTable(db: Database, tableName: String): Unit = {
     val qDropSchema = sqlu"""drop table if exists #$tableName;"""
     try {
        Await.result(db.run(DBIO.seq(
          qDropSchema
        )), Duration.Inf)
      }
     catch {
       case _: Throwable => println(Console.RED +  "Could not drop table." + Console.RESET )
     }
  }
  def addAccount(db: Database, first:String, last:String, username:String, password:String, administrator:Boolean, balance:Int): Unit ={
    val insert = DBIO.seq(
      accounts += (1, first, last, username, password, administrator, balance)
    )
    Await.result(db.run(insert), Duration.Inf)
  }
  println("--------------------------")
  println("|   Welcome to the D&K   |")
  println("|   Bank Application!    |")
  println("--------------------------")

  var masterPassGiven = false
  var masterpass = ""
  while(!masterPassGiven) {
    masterpass = readLine("Please provide database master password: ")
    val encryptedFile = new File("test_encrypted.db")
    val decryptedFile = new File("test.db")

    try {
      decrypt(masterpass, encryptedFile, decryptedFile)
    } catch {
      case ex: Exception =>
        ex.printStackTrace
    }
    if(decryptedFile.exists()) masterPassGiven = true
  }

  println("Master password has been provided")
    val accounts = TableQuery[Accounts]
    val transactions = TableQuery[Transactions]
    val db = Database.forConfig("sqlite")
//    dropTable(db, "accounts")
//    dropTable(db, "transactions")


        // using the functional interface

        // create the table first

        val setup = DBIO.seq( (accounts.schema ++ transactions.schema).createIfNotExists)
        Await.result(db.run(setup), Duration.Inf)

        try {
          // Always start with admin account
          val insert = DBIO.seq(
            accounts += (1, "John", "Smith", "admin", "admin", true, 100)
          )
          Await.result(db.run(insert), Duration.Inf)
        }
        catch {
          case _: Throwable => println(Console.RED +  "Could not create admin account. Likely already exists." + Console.RESET )
        }


          var transactionsLog = Await.result(db.run(sql"""select * from transactions""".as[(Int, Int, Int, Int)]), Duration.Inf).toList.map(Transaction tupled _)
          //println(transactionsLog)
          var approvedUsers = Await.result(db.run(sql"""select * from accounts""".as[(Int, String, String, String, String, Boolean, Int)]), Duration.Inf).toList.map(User tupled _)
          //println(approvedUsers)
//        val insert2 = DBIO.seq(
//          suppliers += ( 3, "Habit Coffee", "552 Pandora St",    "Victoria",    "BC", "V8S1W7")
//        )
//


  var usernameMap: Map[String, String] = (for(a <- approvedUsers) yield a.username -> a.password).toMap

  var user = ""

  while(user != "-1") {
    println()
    println("--------------------------")
    println("|      Please Input      |")
    println("|      Credentials!      |")
    println("--------------------------")
    user = readLine("Username: ")
    val pass = readLine("Password: ")
    val noRealUserFound = Await.result(db.run(sql"""select * from accounts where '#${user}' = username AND password = '#${pass}'""".as[(Int, String, String, String, String, Boolean, Int)]), Duration.Inf).toList.isEmpty
    //val realUser = usernameMap.contains(user) && pass == usernameMap(user)
    if(!noRealUserFound) {
      var loggedIn = true
      var currentUser = approvedUsers.filter(_.username == user)(0)
      while(loggedIn) {
        print("\u001b[2J")
        println("--------------------------")
        println("|   What would you like  |")
        println("|         to do?         |")
        println("--------------------------")
        println()
        println("--------------------------")
        println("| 1. Account Info        |")
        println("| 2. Withdraw            |")
        println("| 3. Deposit             |")
        println("| 4. Transfer            |")
        println("| 5. Transaction History |")
        println("| 6. Add New User        |")
        println("| 7. Save and Logout     |")
        println("--------------------------")
        val opt = readLine("Option Number: ")
        print("\u001b[2J")
        opt match {
          case "1" => accountInfo(currentUser)
          case "2" => currentUser = withdraw(currentUser)
          case "3" => currentUser = deposit(currentUser)
          case "4" => {
            val recId = readLine("Enter Recipient Account Number: ").toInt
            currentUser = transfer(currentUser, approvedUsers.filter(_.id == recId)(0))
          }
          case "5" => transHist(currentUser)
          case "6" => newUser()
          case "7" => loggedIn = false
        }
      }
    } else {
      println("Invalid Credentials, please try again!")
    }
  }

  def accountInfo(usr: User) = {
    println("          Name: " + usr.last + ", " + usr.first)
    println("       Balance: $" + (usr.balance.toDouble / 100))
    println("Account Number: " + usr.id)
    println()
    readLine("Go back?")
  }

  def deposit(user: User):User = {
    if(user.admin) {
      val amt = (readLine("How much?: $").toDouble * 100).toInt
      val accBal = for {account <- accounts if account.username === user.username} yield account.balance
      val updateAction = accBal.update(user.balance + amt)
      Await.result(db.run(updateAction), Duration.Inf)
      Await.result(db.run(DBIO.seq(transactions += (0, -1, user.id, amt))), Duration.Inf)
      refresh(db)
    }else{
      println("NOT ADMIN: You do not have access to deposit")
      refresh(db)
    }
  }
  def withdraw(user: User):User = {
    val amt = (readLine("How much?: $").toDouble * 100).toInt
    val accBal = for { account <- accounts if account.username === user.username } yield account.balance
    val updateAction = accBal.update(user.balance - amt)
    Await.result(db.run(updateAction), Duration.Inf)
    Await.result(db.run(DBIO.seq(transactions += (0, user.id, -1, amt))), Duration.Inf)
    refresh(db)
  }
  def transfer(user1: User, user2: User): User = {
    val amt = (readLine("How much?: $").toDouble * 100).toInt
    val accBal1 = for { account <- accounts if account.username === user1.username } yield account.balance
    val accBal2 = for { account <- accounts if account.username === user2.username } yield account.balance
    val updateAction1 = accBal1.update(user1.balance - amt)
    val updateAction2 = accBal2.update(user1.balance + amt)
    Await.result(db.run(updateAction1), Duration.Inf)
    Await.result(db.run(updateAction2), Duration.Inf)
    Await.result(db.run(DBIO.seq(transactions += (0, user1.id, user2.id, amt))), Duration.Inf)
    refresh(db)
  }

  def transHist(usr: User) = {
    println("----- transactions log ------")
    for(t <- transactionsLog.filter(a => a.fromUserID == usr.id || a.toUserID == usr.id)) {
      if(t.fromUserID == -1) {
        println("Deposited $" + (t.transferAmt.toDouble / 100)  + ".")
      } else if(t.toUserID == -1) {
        println("Withdrew $" + (t.transferAmt.toDouble / 100)  + ".")
      } else if(t.toUserID == usr.id) {
        val sender = approvedUsers.find(_.id == t.fromUserID).get
        println("Received $" + (t.transferAmt.toDouble / 100)  + " from " + sender.last + ", " + sender.first + ".")
      } else {
        val rec = approvedUsers.find(_.id == t.toUserID).get
        println("Sent $" + (t.transferAmt.toDouble / 100)  + " to " + rec.last + ", " + rec.first + ".")
      }
    }
    println()
    readLine("Go back?")
    print("\u001b[2J")
  }

  def newUser() ={
    println("-----------------------")
    println("| Input new user data |")
    println("-----------------------")
    val id = approvedUsers.last.id + 1
    val first = readLine("First Name: ")
    val last = readLine("Last Name: ")
    val username = readLine("Username: ")
    val password = readLine("Password ")
    print("Administrator(true/false): ")
    val admin = readBoolean()
    val balance = readLine("Balance: ").toInt
    val isFound = approvedUsers.find(_.username == username)
    if(isFound == None) {
      Await.result(db.run(DBIO.seq(accounts += (id, first, last, username, password, admin, balance))), Duration.Inf)
      refresh(db)
    } else {
      println("User already exists!")
    }
  }

  def md5HashString(s: String): String = {
    //credit for function to https://alvinalexander.com/source-code/scala-method-create-md5-hash-of-string/
    import java.security.MessageDigest
    import java.math.BigInteger
    val md = MessageDigest.getInstance("MD5")
    val digest = md.digest(s.getBytes)
    val bigInt = new BigInteger(1,digest)
    val hashedString = bigInt.toString(16)
    hashedString
  }
  val encryptedFile = new File("test_encrypted.db")
  val decryptedFile = new File("test.db")

  try {
    encrypt(masterpass, decryptedFile, encryptedFile)
  } catch {
    case ex: Exception =>
      ex.printStackTrace
  }
  deleteFile("test.db")
//        Await.result(db.run(insert2), Duration.Inf)
//
//        // query all tuples in the table
//        Await.result(
//          db.run(suppliers.result).map(_.foreach {
//            case (id, name, street, city, state, zip) => println(s"${name}: ${street} : ${city}")
//          }), Duration.Inf)
//
//        println("----------------------------------------")
//
//        val q = suppliers.filter(_.city === "Victoria")
//
//        Await.result(
//          db.run(q.result).map(_.foreach {
//            case (id, name, street, city, state, zip) => println(s"${name}: ${street} : ${city}")
//          }),
//          Duration.Inf)val insert2 = DBIO.seq(
//          suppliers += ( 3, "Habit Coffee", "552 Pandora St",    "Victoria",    "BC", "V8S1W7")
//        )
//
//        Await.result(db.run(insert2), Duration.Inf)
//
//        // query all tuples in the table
//        Await.result(
//          db.run(suppliers.result).map(_.foreach {
//            case (id, name, street, city, state, zip) => println(s"${name}: ${street} : ${city}")
//          }), Duration.Inf)
//
//        println("----------------------------------------")
//
//        val q = suppliers.filter(_.city === "Victoria")
//
//        Await.result(
//          db.run(q.result).map(_.foreach {
//            case (id, name, street, city, state, zip) => println(s"${name}: ${street} : ${city}")
//          }),
//          Duration.Inf)


        db.close

}
